"""
Emotion Recognition Model.

This module provides functionality to analyze text for emotional content,
extracting emotions, valence, and arousal values.
"""

import os
from typing import Dict,  Any
import logging
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.output_parsers import PydanticOutputParser
from pydantic import BaseModel, Field
from src.utils.openai_utils import get_openai_chat_model
from src.config import EMOTION_MODEL

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Define the data structure for the emotions dictionary
class Emotions(BaseModel):
    Happy: float = Field(description="Score from 0 (not present) to 1 (strongly present)")
    Sad: float = Field(description="Score from 0 (not present) to 1 (strongly present)")
    Angry: float = Field(description="Score from 0 (not present) to 1 (strongly present)")
    Surprised: float = Field(description="Score from 0 (not present) to 1 (strongly present)")
    Fear: float = Field(description="Score from 0 (not present) to 1 (strongly present)")
    Disgust: float = Field(description="Score from 0 (not present) to 1 (strongly present)")


# Define the main output structure
class EmotionAnalysis(BaseModel):
    """Data model for the output of the emotion recognition analysis."""
    emotions: Emotions = Field(description="Dictionary of emotion names to intensity scores")
    valence: float = Field(ge=-1.0, le=1.0, description="Overall positivity/negativity from -1 to 1")
    arousal: float = Field(ge=-1.0, le=1.0, description="Overall emotional intensity from -1 to 1")


class EmotionRecognitionModel:
    """
    A model for recognizing emotions in text.
    
    This class uses a language model to analyze text and extract emotional
    content, including specific emotions (happy, sad, angry, etc.), valence
    (positive/negative), and arousal (intensity).
    """
    
    def __init__(self, temperature: float = 0.2):
        """
        Initialize the emotion recognition model.
        
        Args:
            temperature (float, optional): The temperature setting for the model.
                Defaults to 0.2.
        """
        self.llm = get_openai_chat_model(
            temperature=temperature, 
            model_name=os.getenv("EMOTION_MODEL", "gpt-4o-mini")
        )



                ### Old formating instrutions ###
        # self.format_instructions = """
        # You must respond with a JSON object with the following structure:
        # {
        #     "emotions": {
        #         "Happy": <float 0-1>,
        #         "Sad": <float 0-1>,
        #         "Angry": <float 0-1>,
        #         "Surprised": <float 0-1>,
        #         "Fear": <float 0-1>,
        #         "Disgust": <float 0-1>
        #     },
        #     "valence": <float -1 to 1>,
        #     "arousal": <float -1 to 1>
        # }
        
        # Where:
        # - Each emotion has a score from 0 (not present) to 1 (strongly present)
        # - Valence ranges from -1 (very negative) to 1 (very positive)
        # - Arousal ranges from -1 (very low intensity) to 1 (very high intensity)
        
        # Respond ONLY with the JSON object, no other text.
        # """
        
        # self.prompt = ChatPromptTemplate.from_messages([
        #     ("system", """You are an expert emotion recognition system. 
        #     Analyze the text provided and identify the emotions expressed.
            
        #     {format_instructions}
        #     """),
        #     ("user", "{text}")
        # ])
        
        # self.output_parser = StrOutputParser()



        # PydanticOutputParser handles formatting instructions and parsing automatically.
        self.output_parser = PydanticOutputParser(pydantic_object=EmotionAnalysis)

        # The format instructions are now generated by the parser itself.
        self.prompt = ChatPromptTemplate.from_messages([
            ("system", """You are an expert emotion recognition system. 
            Analyze the text provided and identify the emotions expressed.
            
            {format_instructions}
            """),
            ("user", "{text}")
        ]).partial(format_instructions=self.output_parser.get_format_instructions())
        
        # --- Create a robust, self-correcting chain ---
        self.chain = self.prompt | self.llm | self.output_parser


    
    def analyze_emotion(self, text: str) -> Dict[str, Any]:
        """
        Analyze the emotional content of the provided text.
        
        Args:
            text (str): The text to analyze for emotional content.
            
        Returns:
            Dict[str, Any]: A dictionary containing:
                - emotions: Dict of emotion names to intensity scores (0-1)
                - valence: Overall positivity/negativity (-1 to 1)
                - arousal: Overall emotional intensity (-1 to 1)
        """
        logger.info(f"Analyzing emotion in text: {text[:200]}...")
         
        try:
            # --- Invoke the chain with retries for robustness ---
            # The .with_retry() method automatically handles parsing errors.
            response = self.chain.with_retry().invoke({
                "text": text,
            })

           
            # The output is already a parsed Pydantic object. We convert it to a dict.
            result = response.model_dump()


            logger.debug(f"Emotion analysis result: {result}")
            return result
        except Exception as e:
            # Catch any unexpected errors from the chain execution
            logger.error(f"Error during emotion analysis chain execution: {e}")
            # Fallback to a neutral state to prevent the whole app from crashing
            return {
                "emotions": {"Happy": 0, "Sad": 0, "Angry": 0, "Surprised": 0, "Fear": 0, "Disgust": 0},
                "valence": 0.0,
                "arousal": 0.0
            }